<story-context id="{bmad_folder}/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>3</storyId>
    <title>Structured Logging &amp; Error Handling Foundation</title>
    <status>drafted</status>
    <generatedAt>2025-11-12</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>.bmad-ephemeral/stories/1-3-structured-logging-error-handling-foundation.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>a structured logging system and error handling utilities</iWant>
    <soThat>debugging and monitoring are effective from the start</soThat>
    <tasks>
- Task 1: Implement structured logger utility (AC: #1)
  - Create src/utils/logger.ts with createLogger factory function
  - Implement JSON-formatted log output with timestamp, level, message, context
  - Add correlation ID (requestId) support for request tracing
  - Implement log levels: debug, info, warn, error
  - Add LogContext type with fields: requestId, operation, metadata
  - Add LogEntry type matching tech spec structure
  - Export createLogger function for use across modules

- Task 2: Create custom error classes (AC: #2)
  - Create src/utils/error-handler.ts
  - Define base AppError class extending Error with statusCode and code properties
  - Define APIError class (extends AppError) for external API failures
  - Define ValidationError class (extends AppError) for input validation failures
  - Define ServiceError class (extends AppError) for internal service errors
  - Add toErrorResponse() method that formats errors per PRD FR-3 spec
  - Include retry_after field for rate limiting scenarios
  - Export all error classes

- Task 3: Implement retry utility with exponential backoff (AC: #2, #3)
  - Create src/utils/retry.ts
  - Implement withRetry&lt;T&gt; function with configurable attempts and delays
  - Use exponential backoff pattern: 1s, 2s, 4s (per architecture.md)
  - Integrate with logger to log retry attempts
  - Handle timeout and failure scenarios gracefully
  - Export withRetry function

- Task 4: Write comprehensive tests (AC: #1, #2, #3)
  - Create test/utils/logger.test.ts
  - Test logger creates valid JSON output
  - Test all log levels (debug, info, warn, error)
  - Test context propagation and requestId correlation
  - Create test/utils/error-handler.test.ts
  - Test all custom error classes instantiation
  - Test toErrorResponse() output matches PRD format
  - Test HTTP status codes for each error type
  - Create test/utils/retry.test.ts
  - Test retry logic with exponential backoff
  - Test max retries limit
  - Test successful retry after failure
  - Verify all tests pass with npm test

- Task 5: Create usage examples and documentation (AC: #3)
  - Add logger usage example in src/utils/logger.ts JSDoc
  - Add error handling usage example in src/utils/error-handler.ts JSDoc
  - Add retry usage example in src/utils/retry.ts JSDoc
  - Document logging best practices in Dev Notes
  - Document error handling patterns in Dev Notes
    </tasks>
  </story>

  <acceptanceCriteria>
1. Given the core project structure exists (Story 1.2)
   When I implement a structured logger utility
   Then the logger outputs JSON-formatted logs
   And log entries include: timestamp, level (debug/info/warn/error), message, context
   And the logger supports correlation IDs for request tracing

2. Given the structured logger exists
   When I create error handling utilities
   Then custom error classes exist for: APIError, ValidationError, ServiceError
   And errors include HTTP status codes and user-friendly messages
   And error responses follow PRD format: { error: { code, message, retry_after? } }

3. And Logger can be imported and used across all modules
   And Examples demonstrate usage patterns
   And Logs are compatible with Cloudflare Workers log streaming
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <!-- PRD: Error Response Format Specification -->
      <doc path="docs/PRD.md" title="Product Requirements Document" section="FR-3: Error Handling">
        Error response format: { error: { code: string, message: string, retry_after?: number } }
        Error codes must be machine-readable (e.g., INVALID_QUERY, SERVICE_ERROR)
        User-friendly messages required - no stack traces in production responses
        retry_after field for rate limiting scenarios (optional, in seconds)
      </doc>

      <!-- Architecture: Retry Pattern and Logging -->
      <doc path="docs/architecture.md" title="Architecture Document" section="Consistency Rules: Error Handling">
        Retry logic: 3 attempts with exponential backoff (delays: 1s, 2s, 4s)
        Custom error classes: ValidationError (400), ServiceError (500), APIError (custom status)
        Error classes must include statusCode and code properties
        Where to apply retries: repos.json fetch, gitingest processing, R2 uploads, AI Search queries
      </doc>

      <doc path="docs/architecture.md" title="Architecture Document" section="Consistency Rules: Logging Strategy">
        Structured log format: LogEntry with timestamp (ISO8601), level, message, context
        LogContext includes: requestId (UUID v4), operation (string), metadata (Record&lt;string,any&gt;)
        Log levels: debug (dev), info (prod), warn, error
        Logger usage: createLogger factory pattern for module-level loggers
        What to log: API requests/responses, cache hits/misses, errors, performance metrics
        What NOT to log: secrets, sensitive query text (use hash), large payloads
      </doc>

      <doc path="docs/architecture.md" title="Architecture Document" section="Implementation Patterns">
        File naming: kebab-case.ts (e.g., logger.ts, error-handler.ts, retry.ts)
        Function naming: camelCase (createLogger, withRetry, toErrorResponse)
        Type naming: PascalCase (LogEntry, LogContext, AppError)
        Module pattern: Named exports only (export function createLogger)
        All public types and functions require comprehensive JSDoc comments
      </doc>

      <!-- Tech Spec: Detailed Interfaces and Examples -->
      <doc path=".bmad-ephemeral/stories/tech-spec-epic-1.md" title="Epic 1 Technical Specification" section="Error Classes">
        ValidationError: statusCode=400, code property, used for invalid input/malformed requests
        ServiceError: statusCode (500/503), code property, retryAfter optional, used for service failures
        APIError: custom statusCode, code property, used for specific HTTP error scenarios
        All error classes extend Error, set this.name appropriately
      </doc>

      <doc path=".bmad-ephemeral/stories/tech-spec-epic-1.md" title="Epic 1 Technical Specification" section="Logger API">
        createLogger(baseContext: Partial&lt;LogContext&gt;) returns logger object
        Logger methods: debug(), info(), warn(), error() - each accepts (message: string, metadata?: Record&lt;string,unknown&gt;)
        Usage pattern: const logger = createLogger({ operation: 'fetchRepos' })
        Output: JSON to console.log (Cloudflare Workers streaming compatible)
      </doc>

      <doc path=".bmad-ephemeral/stories/tech-spec-epic-1.md" title="Epic 1 Technical Specification" section="Retry Utility API">
        Function signature: withRetry&lt;T&gt;(fn: () =&gt; Promise&lt;T&gt;, maxRetries = 3, delays = [1000, 2000, 4000]): Promise&lt;T&gt;
        Implements exponential backoff per architecture decision
        Throws last error if all retries exhausted
        Integrates with logger to log retry attempts
      </doc>
    </docs>

    <code>
      <!-- Existing Types to Reuse -->
      <code path="src/types.ts" kind="types" symbol="ErrorResponse" lines="63-76" reason="ErrorResponse interface already defined - validates against PRD FR-3 format">
        Interface includes error.code (string), error.message (string), error.retry_after (optional number)
        Matches PRD specification exactly - no modifications needed
        Story 1.3 error classes should use this interface for toErrorResponse() method
      </code>

      <code path="src/types.ts" kind="types" symbol="RepoMetadata" lines="104-117" reason="Will be used in logger metadata for ingestion operations">
        Includes url, pushedAt, org, name fields
        Logger can reference this type for structured logging in Epic 2
      </code>

      <code path="src/types.ts" kind="types" symbol="CacheEntry" lines="91-102" reason="Will be used in logger metadata for cache operations">
        Includes pushedAt, processedAt, status fields
        Logger can log cache hit/miss with this structure
      </code>

      <!-- Testing Patterns to Follow -->
      <code path="test/types.test.ts" kind="test" symbol="describe blocks" reason="Established test structure pattern - 13 tests, Vitest describe/it structure">
        Pattern: describe('Type Name', () =&gt; { it('validates...', () =&gt; { ... }) })
        Tests validate type structure, edge cases, and spec compliance
        Story 1.3 should follow same pattern for logger, error-handler, retry tests
      </code>
    </code>

    <dependencies>
      <typescript version="^5.5.2">TypeScript compiler and type system</typescript>
      <vitest version="~3.2.0">Test framework with describe/it structure</vitest>
      <cloudflare-vitest-pool version="^0.8.19">Cloudflare Workers test environment</cloudflare-vitest-pool>
      <eslint version="^9.39.1">Code quality linting (pre-commit hook active)</eslint>
      <prettier version="^3.6.2">Code formatting (pre-commit hook active)</prettier>
      <wrangler version="^4.47.0">Cloudflare Workers CLI and deployment</wrangler>
      <husky version="^9.1.7">Git hooks for pre-commit lint/format</husky>
      <lint-staged version="^16.2.6">Run linters on staged files</lint-staged>
    </dependencies>
  </artifacts>

  <constraints>
    <!-- Naming Conventions (CRITICAL for AI agent consistency) -->
    <constraint type="naming">
      Files: kebab-case.ts (logger.ts, error-handler.ts, retry.ts)
      Functions: camelCase (createLogger, withRetry, toErrorResponse)
      Types: PascalCase (LogEntry, LogContext, AppError, ValidationError, ServiceError, APIError)
      Constants: UPPER_SNAKE_CASE if true constants
      Module exports: Named exports only (no default exports except src/index.ts)
    </constraint>

    <!-- Code Quality Standards -->
    <constraint type="quality">
      JSDoc required: All public types and functions must have comprehensive JSDoc comments
      ESLint rules active: no-explicit-any (warn), no-unused-vars (error), prefer-const (error)
      Pre-commit hooks: ESLint + Prettier run automatically - code must pass before commit
      TypeScript strict mode: All code must satisfy strict type checking
    </constraint>

    <!-- Testing Requirements -->
    <constraint type="testing">
      Test location: test/utils/*.test.ts (co-located with module purpose)
      Test structure: Vitest describe blocks for grouping, it/test for cases
      Test coverage: Target 80%+ on core logic (per architecture.md)
      Test quality: Cover edge cases, validate spec compliance
      Pattern reference: test/types.test.ts has 13 tests - follow similar structure
    </constraint>

    <!-- Architecture Patterns (From Dev Notes Story 1.2) -->
    <constraint type="architecture">
      src/utils/ directory: Created in Story 1.2, ready for logger.ts, error-handler.ts, retry.ts
      src/types.ts: ErrorResponse already exists - DO NOT recreate, reuse for toErrorResponse()
      No new types in utils: Add LogEntry, LogContext to src/types.ts if not present
      Import pattern: Relative imports for local modules (e.g., import { ErrorResponse } from '../types')
    </constraint>

    <!-- Error Handling Standards -->
    <constraint type="error-handling">
      Error response format: MUST match PRD FR-3 spec exactly ({ error: { code, message, retry_after? } })
      No stack traces in production: Error messages must be user-friendly
      Retry pattern: MUST be 3 attempts with exponential backoff (1s, 2s, 4s) - no deviation
      Error class hierarchy: All custom errors extend Error, set this.name and this.code
    </constraint>

    <!-- Logging Standards -->
    <constraint type="logging">
      Output format: JSON only via console.log (Cloudflare Workers log streaming compatible)
      Timestamp format: ISO 8601 (e.g., 2025-11-12T10:00:00.000Z)
      RequestId: UUID v4 format for correlation
      No secrets: Never log API keys, tokens, or sensitive data
      No large payloads: Log size/count instead of full content
    </constraint>

    <!-- Cloudflare Workers Compatibility -->
    <constraint type="platform">
      Runtime: workerd (Cloudflare Workers V8 runtime)
      No Node.js APIs: Avoid Node-specific APIs unless polyfilled
      console.log: Primary output mechanism (goes to Cloudflare Workers logs)
      Performance: Logger must be lightweight (edge compute constraints)
    </constraint>
  </constraints>

  <interfaces>
    <!-- Logger Interface -->
    <interface name="createLogger" kind="function signature" signature="createLogger(baseContext: Partial&lt;LogContext&gt;): Logger" path="src/utils/logger.ts">
      Factory function that returns a logger instance with bound context
      Logger object has methods: debug(message, metadata?), info(message, metadata?), warn(message, metadata?), error(message, metadata?)
      Base context merged with per-call metadata
      Example: const logger = createLogger({ operation: 'fetchRepos' }); logger.info('Fetched', { count: 100 });
    </interface>

    <interface name="LogEntry" kind="type" signature="interface LogEntry { timestamp: string; level: 'debug' | 'info' | 'warn' | 'error'; message: string; context: LogContext; }" path="src/types.ts">
      Structure of JSON log output
      Timestamp is ISO 8601 string
      Level determines log severity
      Context includes requestId, operation, and optional metadata
    </interface>

    <interface name="LogContext" kind="type" signature="interface LogContext { requestId?: string; operation: string; metadata?: Record&lt;string, unknown&gt;; }" path="src/types.ts">
      Context attached to every log entry
      requestId is optional UUID v4 for request tracing
      operation is required string identifying the function/module
      metadata is optional key-value pairs for additional context
    </interface>

    <interface name="withRetry" kind="function signature" signature="withRetry&lt;T&gt;(fn: () =&gt; Promise&lt;T&gt;, maxRetries?: number, delays?: number[]): Promise&lt;T&gt;" path="src/utils/retry.ts">
      Generic retry utility with exponential backoff
      Default maxRetries: 3
      Default delays: [1000, 2000, 4000] milliseconds
      Throws last error if all retries exhausted
      Integrates with logger to log retry attempts
    </interface>

    <interface name="toErrorResponse" kind="method" signature="toErrorResponse(): ErrorResponse" path="src/utils/error-handler.ts">
      Method on all custom error classes
      Returns ErrorResponse object matching PRD FR-3 format
      Includes code (from error.code), message (from error.message), and optional retry_after
      Used by API handlers to format error responses
    </interface>

    <!-- Error Class Interfaces -->
    <interface name="ValidationError" kind="class" signature="class ValidationError extends Error { statusCode: 400; code: string; toErrorResponse(): ErrorResponse }" path="src/utils/error-handler.ts">
      Used for invalid input, malformed requests, validation failures
      Always returns HTTP 400 status code
      Code property is customizable (default: VALIDATION_ERROR)
    </interface>

    <interface name="ServiceError" kind="class" signature="class ServiceError extends Error { statusCode: number; code: string; retryAfter?: number; toErrorResponse(): ErrorResponse }" path="src/utils/error-handler.ts">
      Used for internal service failures, dependency unavailability
      StatusCode can be 500 (internal error) or 503 (service unavailable)
      Optional retryAfter property for retry-after header value
    </interface>

    <interface name="APIError" kind="class" signature="class APIError extends Error { statusCode: number; code: string; toErrorResponse(): ErrorResponse }" path="src/utils/error-handler.ts">
      Generic API error with custom HTTP status code
      Used for specific HTTP error scenarios (502, 503, etc.)
      Flexible for external API failures
    </interface>
  </interfaces>
  <tests>
    <standards>
      Testing framework: Vitest 3.2.0 with @cloudflare/vitest-pool-workers for Workers runtime emulation
      Test structure: describe() blocks for grouping related tests, it() or test() for individual test cases
      Test pattern established in test/types.test.ts: 13 tests covering type validation, edge cases, and spec compliance
      Coverage target: 80%+ on core logic (per architecture.md NFR-Performance requirements)
      Test execution: npm test (runs all tests), npm test -- --watch (watch mode for development)
      Mock strategy: Mock console.log for logger tests to capture output, use fake timers (vi.useFakeTimers()) for retry delay testing
      Test both success and failure paths for all utilities
      Validate that error classes format responses correctly per PRD FR-3 specification
    </standards>

    <locations>
      test/utils/logger.test.ts - Tests for structured logger utility (~10-15 test cases)
      test/utils/error-handler.test.ts - Tests for custom error classes (~8-12 test cases covering all error types and toErrorResponse)
      test/utils/retry.test.ts - Tests for retry logic (~6-8 test cases covering success, failure, timing, max retries)
      Pattern: Co-located with module purpose in test/utils/ directory (established in Story 1.2)
    </locations>

    <ideas>
      <!-- Logger Tests (AC #1) -->
      <test-idea ac="1" module="logger">Test createLogger creates valid JSON output</test-idea>
      <test-idea ac="1" module="logger">Test all log levels output correctly (debug, info, warn, error)</test-idea>
      <test-idea ac="1" module="logger">Test log entries include required fields: timestamp, level, message, context</test-idea>
      <test-idea ac="1" module="logger">Test timestamp is valid ISO 8601 format</test-idea>
      <test-idea ac="1" module="logger">Test context includes requestId when provided</test-idea>
      <test-idea ac="1" module="logger">Test context includes operation field (required)</test-idea>
      <test-idea ac="1" module="logger">Test metadata merges correctly (baseContext + per-call metadata)</test-idea>
      <test-idea ac="1" module="logger">Test logger handles undefined/null metadata gracefully</test-idea>
      <test-idea ac="1" module="logger">Test JSON output is parseable and well-formed</test-idea>

      <!-- Error Handler Tests (AC #2) -->
      <test-idea ac="2" module="error-handler">Test ValidationError has statusCode 400</test-idea>
      <test-idea ac="2" module="error-handler">Test ValidationError.toErrorResponse() returns correct ErrorResponse format</test-idea>
      <test-idea ac="2" module="error-handler">Test ServiceError accepts custom statusCode (500 or 503)</test-idea>
      <test-idea ac="2" module="error-handler">Test ServiceError.toErrorResponse() includes retry_after when provided</test-idea>
      <test-idea ac="2" module="error-handler">Test APIError accepts any HTTP status code</test-idea>
      <test-idea ac="2" module="error-handler">Test APIError.toErrorResponse() includes custom code and message</test-idea>
      <test-idea ac="2" module="error-handler">Test all error classes extend Error properly (instanceof checks)</test-idea>
      <test-idea ac="2" module="error-handler">Test error.name property is set correctly for each class</test-idea>
      <test-idea ac="2" module="error-handler">Test toErrorResponse() format matches PRD FR-3 specification exactly</test-idea>
      <test-idea ac="2" module="error-handler">Test error messages are user-friendly (no stack traces)</test-idea>

      <!-- Retry Utility Tests (AC #2, #3) -->
      <test-idea ac="2,3" module="retry">Test withRetry succeeds on first attempt when function succeeds</test-idea>
      <test-idea ac="2,3" module="retry">Test withRetry retries on failure with exponential backoff (1s, 2s, 4s)</test-idea>
      <test-idea ac="2,3" module="retry">Test withRetry respects maxRetries limit (throws after 3 attempts)</test-idea>
      <test-idea ac="2,3" module="retry">Test withRetry succeeds after 2 failures (retry success path)</test-idea>
      <test-idea ac="2,3" module="retry">Test withRetry throws last error when all retries exhausted</test-idea>
      <test-idea ac="2,3" module="retry">Test retry delays are accurate using fake timers (vi.useFakeTimers)</test-idea>
      <test-idea ac="2,3" module="retry">Test withRetry works with custom delays array</test-idea>
      <test-idea ac="2,3" module="retry">Test withRetry works with custom maxRetries value</test-idea>

      <!-- Integration Tests (AC #3) -->
      <test-idea ac="3" module="integration">Test logger can be imported from other modules (import path validation)</test-idea>
      <test-idea ac="3" module="integration">Test error classes can be imported and used across modules</test-idea>
      <test-idea ac="3" module="integration">Test retry utility integrates with logger (logs retry attempts)</test-idea>
      <test-idea ac="3" module="integration">Test all exports are named exports (no default exports)</test-idea>
    </ideas>
  </tests>
</story-context>
